# Code Challenge - Flicket

## Get it up and running.

If you using [mise](https://mise.jdx.dev/) already - then this repo will auto install all the tools that you might need to run it. if your not using mise, no worries, keep reading.

If you have `skaffold` (or install it with `brew install skaffold`) and you have a kubernetes local (minikube, k3d, docker with k8s enabled etc) environment handy, then running `skaffold dev` will build containers and spin up web-app, api and postgres containers in a 'production like' environment.

Otherwise the following commands will work just as well.

```bash
# start postgres
docker run -d \
  --name postgres \
  -e POSTGRES_USER=postgres \
  -e POSTGRES_PASSWORD=postgres \
  -e POSTGRES_DB=flicket \
  -p 5432:5432 \
  postgres:latest

# start api
cd components/api
npm i
DB_HOST=127.0.0.1 DB_PORT=5432 DB_USERNAME=postgres DB_PASSWORD=postgres DB_NAME=flicket NODE_ENV=development PORT=3000 DB_SYNCHRONIZE=true DB_MIGRATIONS_RUN=true LOG_LEVEL=debug npm run start:dev

# start web app
cd components/web-app
npm i
VITE_API_URL=http://localhost:3000  npm run dev
```

I inlined the env vars as it was a bit of an afterthought - i was originally working in skaffold, until the rebuild time got too much for efficient development.

There is a small, but modest test suite that validates overselling and concurrency. it's built with [BATS](https://github.com/bats-core/bats-core)

```bash
# run tests
test/run-tests.sh
```

Throughout this code, i've left `TODO` comments, mostly when talking about things that i would do differently. I've by no means captured everything.

Much of the code here is generated by AI. However every line of the generated code (in the API) has been reviewed, edited and explicitly approved by me. In the frontend, buy the time i got to it i was running against time limits for the task - so i havnt reviewed ever line - but i have validated that the frontend works as intended - mostly.

I tried to get clever with the frontend, and add additional features (totally outside of the scope of the task, and also outside of the time allocated for this task) I never got it working but i've left it in regardless as its not currently harming anything and I believe the concept could be an interesting talking point. The feature i tried to add was to 'stream' events in realtime to the connected clients, so that can see a 'ticker' of sorts on the app. in my head this was a gimicky sales tool, designed to entice the user to purchase quickly to avoid missing out. I never got the streaming working - and (despite spending time over and above the alloted 4 hours) i couldn't quite find the bug. I can see the frontend should be right, it appears the backend is not emit it correctly.

The work in `skaffold` is intended to represent forward thinking of a production setup. ther are many things about it that are not produciton ready - but its a starting point. (when dev and prod systems are similar, you find issues earlier)

## Concurrency

I've opted for handling concurrency at a DB level. Locking the event row, creating a ticket allocation, decrementing the available count on the event, then committing the transaction. This solution leaves alot to be desired it may struggle to scale - its also not a great experience for the user to wait - as ever individual entity will fight for the lock. I've attempted to reduce this through the concept of an 'allocation' the smallest pice I could feasible construct to guarantee consistency whilst still giving the user what they want (the ticket) the allocation however is follows the 'time based' concept and (in theory - its not implemented well here) after a period of time the ticket allocation will expire if not paid for, and the ticket will release to the event pool.

Additional Note: Added 2nd June
It was bugging me that i couldn't get the streaming to work so I looked again today - its still out of scope of the task but I didn't manage to get it working today. The short version is I needed to use a Replay subject set with a history of 1, so that new subscribers will receive the latest  stastics always, without needing to wait for new events to come in. In resolving this, oi also found a pretty major error in the webapp - specifically that tickets were never being 'confirmed' as purchased. - they would sit in reserved status until they expired. This was due to how the app was calling the api's and is now also resolved. 

---

# Flicket - Ticket Booking System

A scalable ticket booking application with concurrency control. This project implements a system for managing events and ticket purchases with proper handling of race conditions.

## Project Structure

- `components/api` - NestJS backend
- `components/web-app` - React frontend with Vite
- `k8s` - Kubernetes manifests

## Setup Instructions

### Prerequisites

- Node.js (v18+)
- npm
- PostgreSQL
- Docker

(to use skaffold)

- Kubernetes cluster (local or remote)
- Skaffold

### Backend Setup (NestJS)

1. Navigate to the backend directory:

   ```
   cd components/api
   ```

2. Install dependencies:
   ```
   npm install
   ```

The API will be available at `http://localhost:3000`.

### Frontend Setup (React + Vite)

1. Navigate to the frontend directory:

   ```
   cd components/web-app
   ```

2. Install dependencies:

   ```
   npm install
   ```

3. Start the development server:
   ```
   npm run dev
   ```

The web application will be available at `http://localhost:5173`.

## Docker Setup

### Running Individual Docker Images

#### API

To build the API Docker image:

```
cd components/api
docker build -t flicket-api .
```

To run the API container:

```
docker run -p 3000:3000 flicket-api
```

n.b. this will not include any env vars

#### Web App

To build the web app Docker image:

```
cd components/web-app
docker build -t flicket-web-app .
```

To run the web app container:

```
docker run -p 4173:4173 flicket-web-app
```

## Skaffold Setup

This project uses Skaffold for continuous development with Kubernetes. The setup includes:

- API deployment with PostgreSQL configuration
- Web app deployment
- PostgreSQL database deployment
- Ingress configuration

### Running with Skaffold

To start development with Skaffold:

```
skaffold dev
```

This will:

1. Build the Docker images for API and web app
2. Deploy all components to your Kubernetes cluster
3. Set up port forwarding:
   - API: http://localhost:3000
   - Web app: http://localhost:8080
   - PostgreSQL: localhost:5432
4. Watch for changes and rebuild/redeploy as needed

To deploy once without watching for changes:

```
skaffold run
```

## Environment Variables

### Backend (.env)

- `DB_HOST` - PostgreSQL host (default: localhost)
- `DB_PORT` - PostgreSQL port (default: 5432)
- `DB_USERNAME` - PostgreSQL username (default: postgres)
- `DB_PASSWORD` - PostgreSQL password (default: postgres)
- `DB_NAME` - PostgreSQL database name (default: flicket)
- `PORT` - API server port (default: 3000)
- `NODE_ENV` - Environment (development, production)
- `DB_SYNCHRONIZE` - Auto-sync database schema (default: true in development)
- `DB_MIGRATIONS_RUN` - Run migrations automatically (default: true in development)
